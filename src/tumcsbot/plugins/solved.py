#!/usr/bin/env python3

# See LICENSE file for copyright and license details.
# TUM CS Bot - https://github.com/ro-i/tumcsbot

import urllib.parse

from typing import Any, Dict, Iterable, List, Optional, Union

from tumcsbot.lib import Response
from tumcsbot.plugin import Plugin


class Solved(Plugin):
    plugin_name = 'solved'
    events = ['reaction']
    solved_emoji_name: str = 'check'
    msg_pattern: str = ' has been marked as solution by '
    msg_template: str = '[This answer â†‘{}]({})' + msg_pattern
    mention_template: str = '@_**{}**'
    # arguments: stream id, topic name, message id
    path: str = '#narrow/stream/{}/topic/{}/near/{}'

    def is_responsible(self, event: Dict[str, Any]) -> bool:
        return (
            event['type'] in self.events
            and event['op'] == 'add' # TODO: handle "remove" case?
            and event['emoji_name'] == self.solved_emoji_name
            and event['user_id'] != self.client.id
        )

    def handle_event(
        self,
        event: Dict[str, Any],
        **kwargs: Any
    ) -> Union[Response, Iterable[Response]]:
        # Try to get the message.
        result = self._get_message(event['message_id'])
        if result['result'] != 'success':
            return Response.none()
        if not result['found_anchor']:
            # Try again. Message has been sent before the bot subscribed to
            # the corresponding stream.
            result = self._get_message(event['message_id'], True)

        if (result['result'] != 'success'
                or not result['found_anchor']
                or result['messages'][0]['type'] == 'private'):
            return Response.none()

        message: Dict[str, Any] = result['messages'][0]

        # Check if this message is a message generated by this plugin.
        # Those messages may not be marked as solution again.
        if (message['sender_id'] == self.client.id
                and self.msg_pattern in message['content']):
            return Response.none()

        # Get the user who reacted on this message.
        result = self.client.get_user_by_id(event['user_id'])
        if result['result'] != 'success':
            return Response.none()
        user_name: str = result['user']['full_name']

        # Build the link to the message.
        url: str = self._build_url(
            message['id'], message['subject'], message['stream_id']
        )

        # Build the message the bot might write.
        bot_message: str = self.msg_template.format(message['id'], url)

        # Check if there already exists a bot message regarding this message.
        result = self._search_bot_message(message)
        if result['result'] != 'success' or len(result['messages']) < 1:
            return Response.build_message(
                None,
                msg_type = 'stream',
                to = message['stream_id'],
                subject = message['subject'],
                content = bot_message + self.mention_template.format(user_name)
            )

        # Get previous bot message.
        old_bot_message: Dict[str, Any] = result['messages'][0]

        # Reject multiple reactions of the same user.
        if user_name in old_bot_message['content'][len(bot_message) + 4:-2]\
                .split('**, @_**'):
            return Response.none()

        # Add user to the reaction list.
        self.client.update_message({
            'message_id': old_bot_message['id'],
            'content': (old_bot_message['content'] + ', '
                        + self.mention_template.format(user_name))
        })

        return Response.none()

    def _build_url(
        self,
        message_id: int,
        subject: str,
        stream_id: int,
    ) -> str:
        """Build the url for accessing the message.

        The url should link to the message embedded into the
        corresponding topic view, i.e., the messages displayed around
        the specific message should be those of the same topic.
        """
        # Fix strange behavior of Zulip which does not accept literal periods.
        topic: str = urllib.parse.quote(subject, safe = '').replace('.', '%2E')

        # Stream representation defaults to the stream id.
        stream: str = str(stream_id)
        # If possible, get also the stream name. (Otherwise, the link will not
        # work on the Zulip iOS App.)
        stream_name: Optional[str] = self.client.get_stream_name(stream_id)
        if stream_name is not None:
            stream += '-' + urllib.parse.quote(stream_name, safe = '')\
                .replace('.', '%2E')

        # Get host url (removing trailing 'api/').
        base_url: str = self.client.base_url[:-4]

        # Build the full url.
        return base_url + self.path.format(stream, topic, message_id)

    def _get_message(
        self,
        message_id: int,
        public_streams: bool = False
    ) -> Dict[str, Any]:
        narrow: List[Dict[str, str]] = []

        if public_streams:
            narrow = [{'operator': 'streams', 'operand': 'public'}]

        return self.client.get_messages({
            'anchor': message_id,
            'num_before': 0,
            'num_after': 0,
            'narrow': narrow
        })

    def _search_bot_message(
        self,
        message: Dict[str, Any],
    ) -> Dict[str, Any]:
        search: str = 'â†‘{}'.format(message['id']) + self.msg_pattern

        result: Dict[str, Any] =  self.client.get_messages({
            'anchor': message['id'],
            'num_before': 0,
            'num_after': 1,
            'narrow': [
                { 'operator': 'stream', 'operand': message['stream_id'] },
                { 'operator': 'topic', 'operand': message['subject'] },
                { 'operator': 'sender', 'operand': self.client.id },
                { 'operator': 'has', 'operand': 'link' },
                { 'operator': 'search', 'operand': search }
            ]
        })

        return result
